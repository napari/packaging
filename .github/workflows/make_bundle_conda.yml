on:
  push:
    # Sequence of patterns matched against refs/tags
    tags:
      - "v*" # Push events to matching v*, i.e. v1.0, v20.15.10
    branches:
      - main
  pull_request:
    branches:
      - main
    paths-ignore:
      - "docs/**"
  schedule:
    - cron: "0 0 * * *"
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

name: Conda

jobs:
  packages:
    name: Create packages
    runs-on: ubuntu-latest
    if: github.repository == 'napari/packaging'
    env:
      conda_bld_suffix: /napari-feedstock/build_artifacts/
    outputs:
      artifact-id: ${{ steps.artifact-id.outputs.name }}

    steps:
      - name: Checkout packaging code
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
          path: napari-packaging

      - name: Checkout napari source
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
          repository: napari/napari
          path: napari-source

      - name: Checkout conda-forge feedstock
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
          repository: conda-forge/napari-feedstock
          path: napari-feedstock

      - name: install micromamba
        uses: mamba-org/provision-with-micromamba@main
        with:
          environment-file: napari-packaging/environments/ci_packages_environment.yml

      - name: install napari
        shell: bash -el {0}
        working-directory: napari-source
        run: |
          set -x
          pip install -e . --no-deps -vvv
          napari_version=$(python -c 'from importlib.metadata import version; print(version("napari"))')
          echo "NAPARI_VERSION=$napari_version" >> $GITHUB_ENV
          echo "NAPARI_ARCH=$(python ../napari-packaging/build_installers.py --arch)" >> $GITHUB_ENV

      - name: Patch and rerender feedstock
        shell: bash -el {0}
        working-directory: napari-feedstock
        run: |
          set -euxo pipefail
          # rm recipe from conda-forge's feedstock and replace with our napari/packaging version
          rm -rf recipe/
          cp -r ../napari-packaging/conda-recipe recipe

          sed -i -e "s|{% set version = \".*\" %}|{% set version = \"${NAPARI_VERSION}\" %}|" \
                 -e "s|{% set build = [0-9]+ %}|{% set build = 0 %}|" \
                 recipe/meta.yaml
          # make sure the meta.yaml points to the local source, in case we break
          # this when updating from upstream
          grep -e "path: /home/conda" recipe/meta.yaml

          conda-smithy rerender
          git diff
          mv ${GITHUB_WORKSPACE}/napari-source .

      - name: Run build scripts (PyQt)
        shell: bash -el {0}
        working-directory: napari-feedstock
        env:
          DOCKER_IMAGE: quay.io/condaforge/linux-anvil-comp7
          CONFIG: linux_64_qt_bindingspyqt # filename under feedstock's .ci_support/
          CI: github_actions
          CONDA_BLD_PATH: "${{ github.workspace }}${{ env.conda_bld_suffix }}"
        run: |
          export
          ./.scripts/run_docker_build.sh

      - name: Run build scripts (PySide)
        shell: bash -el {0}
        working-directory: napari-feedstock
        env:
          DOCKER_IMAGE: quay.io/condaforge/linux-anvil-comp7
          CONFIG: linux_64_qt_bindingspyside2 # filename under feedstock's .ci_support/
          CI: github_actions
          CONDA_BLD_PATH: "${{ github.workspace }}${{ env.conda_bld_suffix }}"
        run: |
          ./.scripts/run_docker_build.sh

      - name: Export artifact identifier
        id: artifact-id
        run: |
          name=pkgs-napari-${{ env.NAPARI_VERSION }}-${{ github.run_id }}-${{ github.run_number }}-${{ github.run_attempt }}
          echo "::set-output name=name::${name}"

      - name: Upload packages as artifacts
        uses: actions/upload-artifact@v2
        with:
          name: ${{ steps.artifact-id.outputs.name }}
          path: ${{ github.workspace }}${{ env.conda_bld_suffix }}noarch/*.tar.bz2

      - name: Upload to anaconda.org
        shell: bash -el {0}
        # Only upload to anaconda.org/napari if it's a nightly (version with *dev* suffix)
        # or a tag event (either RC or final). Nightlies and RCs go to the nightly channel.
        if: github.event_name == 'schedule' || startsWith(github.ref, 'refs/tags/v')
        run: |
          label_args=""
          if [[ $NAPARI_VERSION == *rc* || $NAPARI_VERSION == *dev* ]]; then
            label_args="-l nightly"
          fi
          anaconda \
            -t ${{ secrets.ANACONDA_TOKEN }} \
            upload \
            --skip-existing \
            -u napari \
            $label_args \
            ${GITHUB_WORKSPACE}${conda_bld_suffix}noarch/*.tar.bz2

  installers:
    name: Bundle ${{ matrix.target-platform }}
    runs-on: ${{ matrix.os }}
    needs: packages
    if: github.repository == 'napari/packaging'
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-18.04
            python-version: "3.9"
            target-platform: "linux-64"
          - os: macos-latest
            python-version: "3.9"
            target-platform: "osx-64"
          - os: macos-latest
            python-version: "3.9"
            target-platform: "osx-arm64"
          - os: windows-latest
            python-version: "3.8"
            target-platform: "win-64"
    env:
      GITHUB_TOKEN: ${{ github.token }}
      DISPLAY: ":99.0"
      CONDA_BLD_PATH: ${{ github.workspace }}/conda-bld
      CONSTRUCTOR_TARGET_PLATFORM: ${{ matrix.target-platform }}
      CONDA_NUMBER_CHANNEL_NOTICES: 0
      CONDA_EXPERIMENTAL_SOLVER: libmamba

    outputs:
      licenses-artifact: ${{ steps.licenses.outputs.licenses_artifact }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
          path: napari-packaging

      - name: Checkout napari/napari
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
          repository: napari/napari
          path: napari-source

      - name: install micromamba
        uses: mamba-org/provision-with-micromamba@main
        with:
          environment-file: napari-packaging/environments/ci_installers_environment.yml
          extra-specs: |
            python=${{ matrix.python-version }}

      - name: Conda info
        shell: bash -el {0}
        run: |
          set -x
          conda info -a
          conda config --show-sources
          mkdir -p ${CONDA_BLD_PATH}/noarch

      - name: set up build dependencies
        shell: bash -el {0}
        working-directory: napari-source
        run: |
          python -m pip install -e '.[bundle_build]'

      - name: Download local build artifacts (napari)
        uses: actions/download-artifact@v3
        with:
          name: ${{ needs.packages.outputs.artifact-id }}
          path: ${{ env.CONDA_BLD_PATH }}/noarch

      - name: Index local packages (if any)
        shell: bash -el {0}
        working-directory: napari-packaging
        run: |
          pkgs=$(shopt -s nullglob dotglob; echo "${CONDA_BLD_PATH}/noarch/*.tar.bz2")
          if (( ${#pkgs} )); then
            conda index "${CONDA_BLD_PATH}"
            conda search -c local --override-channels
            echo CONSTRUCTOR_USE_LOCAL=1 >> $GITHUB_ENV
          else
            echo "No local packages found, assuming latest release"
          fi

      - name: get tag / arch-suffix / extension / artifact-name / conda-standalone
        shell: bash -el {0}
        working-directory: napari-packaging
        run: |
          VER=$(python build_installers.py --version --location=../napari-source)
          echo "version=${VER}" >> $GITHUB_ENV
          echo "Napari version: ${VER}"
          INST_VER=$(python build_installers.py --installer-version)
          echo "installer_version=${INST_VER}" >> $GITHUB_ENV
          echo "Installer version: ${INST_VER}"
          ARCH_SUFFIX=$(python build_installers.py --arch)
          echo "arch-suffix=${ARCH_SUFFIX}" >> $GITHUB_ENV
          echo "Machine: ${ARCH_SUFFIX}"
          EXTENSION=$(python build_installers.py --ext)
          echo "extension=${EXTENSION}" >> $GITHUB_ENV
          echo "Extension: ${EXTENSION}"
          ARTIFACT_NAME=$(python build_installers.py --artifact-name)
          echo "artifact-name=${ARTIFACT_NAME}" >> $GITHUB_ENV
          echo "Expected artifact name: ${ARTIFACT_NAME}"

          host_platform=$(conda info --json | jq -r .platform)
          if [[ "$host_platform" != "$CONSTRUCTOR_TARGET_PLATFORM" ]]; then
            prefix="${RUNNER_TEMP}/conda-exe"
            CONDA_SUBDIR=$CONSTRUCTOR_TARGET_PLATFORM \
              conda create -yq -p "${prefix}" -c napari/label/bundle_tools conda-standalone
            echo "CONSTRUCTOR_CONDA_EXE=${prefix}/standalone_conda/conda.exe" >> $GITHUB_ENV
          fi

      # instructions taken from
      # https://docs.github.com/en/actions/deployment/deploying-xcode-applications/installing-an-apple-certificate-on-macos-runners-for-xcode-development#add-a-step-to-your-workflow
      - name: Load signing certificate (MacOS)
        shell: bash -el {0}
        # We only sign pushes to main, nightlies, RCs and final releases
        if: runner.os == 'macOS' && (github.event_name == 'schedule' || github.event_name == 'push')
        env:
          APPLE_APPLICATION_CERTIFICATE_BASE64: ${{ secrets.APPLE_APPLICATION_CERTIFICATE_BASE64 }}
          APPLE_INSTALLER_CERTIFICATE_BASE64: ${{ secrets.APPLE_INSTALLER_CERTIFICATE_BASE64 }}
          APPLE_INSTALLER_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_INSTALLER_CERTIFICATE_PASSWORD }}
          TEMP_KEYCHAIN_PASSWORD: ${{ secrets.TEMP_KEYCHAIN_PASSWORD }}
        run: |
          # create variables
          INSTALLER_CERTIFICATE_PATH="$RUNNER_TEMP/installer_developer_cert.p12"
          APPLICATION_CERTIFICATE_PATH="$RUNNER_TEMP/application_developer_cert.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/installer-signing.keychain-db"

          # import certificate and provisioning profile from secrets
          echo -n "$APPLE_INSTALLER_CERTIFICATE_BASE64" | base64 --decode --output $INSTALLER_CERTIFICATE_PATH
          echo -n "$APPLE_APPLICATION_CERTIFICATE_BASE64" | base64 --decode --output $APPLICATION_CERTIFICATE_PATH

          # create temporary keychain
          security create-keychain -p "$TEMP_KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$TEMP_KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # import certificate to keychain
          security import $INSTALLER_CERTIFICATE_PATH -P $APPLE_INSTALLER_CERTIFICATE_PASSWORD -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security import $APPLICATION_CERTIFICATE_PATH -P $APPLE_INSTALLER_CERTIFICATE_PASSWORD -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # export identity name
          signing_identity=$(security find-identity $KEYCHAIN_PATH | grep -m 1 -o '"Developer ID Installer.*"' | tr -d '"')
          notarization_identity=$(security find-identity $KEYCHAIN_PATH | grep -m 1 -o '"Developer ID Application.*"' | tr -d '"')

          echo "CONSTRUCTOR_SIGNING_IDENTITY=${signing_identity}" >> $GITHUB_ENV
          echo "CONSTRUCTOR_NOTARIZATION_IDENTITY=${notarization_identity}" >> $GITHUB_ENV

          # The conda environment might contain a totally different codesign
          # which would clobber the Apple's codesign (the one we need)
          _codesign=$(which codesign)
          if [[ $_codesign =~ ${CONDA_PREFIX}.* ]]; then
            mv "${_codesign}" "${_codesign}.in_conda_env"
          fi

      - name: Load signing certificate (Windows)
        # We only sign pushes to main, nightlies, RCs and final releases
        if: runner.os == 'Windows' && (github.event_name == 'schedule' || github.event_name == 'push')
        # We are signing with Apple's certificate to provide _something_
        # This is not trusted by Windows so the warnings are still there, but curious users
        # will be able to check it's actually us if necessary
        run: |
          Set-Content -Path "${{ runner.temp }}/certificate.b64.txt" -Value '${{ secrets.APPLE_APPLICATION_CERTIFICATE_BASE64 }}'
          certutil -decode "${{ runner.temp }}/certificate.b64.txt" "${{ runner.temp }}/certificate.pfx"

          echo "CONSTRUCTOR_SIGNING_CERTIFICATE=${{ runner.temp }}/certificate.pfx" >> $Env:GITHUB_ENV
          echo "CONSTRUCTOR_PFX_CERTIFICATE_PASSWORD=${{ secrets.APPLE_INSTALLER_CERTIFICATE_PASSWORD }}" >> $Env:GITHUB_ENV
          echo "CONSTRUCTOR_SIGNTOOL_PATH=C:/Program Files (x86)/Windows Kits/10/bin/10.0.17763.0/x86/signtool.exe" >> $Env:GITHUB_ENV

      # TODO: Consider a refactor here; maybe an org action we can reuse or at least a script
      - name: Make Bundle (Linux)
        if: runner.os == 'Linux'
        shell: bash -el {0}
        working-directory: napari-packaging
        run: |
          echo "::group::Install apt dependencies"
          sudo apt-get update
          sudo apt-get install -y libdbus-1-3 libxkbcommon-x11-0 libxcb-icccm4 \
            libxcb-image0 libxcb-keysyms1 libxcb-randr0 libxcb-render-util0 \
            libxcb-xinerama0 libxcb-xfixes0 libxcb-shape0 libqt5gui5
          echo "::endgroup::"
          xvfb-run --auto-servernum python build_installers.py --location=../napari-source

      - name: Make Bundle (MacOS/Windows)
        shell: bash -el {0}
        if: runner.os != 'Linux'
        working-directory: napari-packaging
        run: python build_installers.py --location=../napari-source

      - name: Collect licenses
        id: licenses
        shell: bash -el {0}
        working-directory: napari-packaging
        run: |
          licenses_zip_path=$(python build_installers.py --licenses)
          echo "LICENSES_ARTIFACT_PATH=$licenses_zip_path" >> $GITHUB_ENV
          echo "LICENSES_ARTIFACT_NAME=$(basename ${licenses_zip_path})" >> $GITHUB_ENV
          echo "::set-output name=licenses_artifact::$licenses_zip_path"

      - name: Upload License Artifact
        uses: actions/upload-artifact@v2
        with:
          path: ${{ env.LICENSES_ARTIFACT_PATH }}
          name: ${{ env.LICENSES_ARTIFACT_NAME }}

      - name: Notarize Bundle (macOS)
        # We only sign pushes to main, nightlies, RCs and final releases
        if: runner.os == 'macOS' && (github.event_name == 'schedule' || github.event_name == 'push')
        uses: devbotsxyz/xcode-notarize@v1
        with:
          product-path: ${{ github.workspace }}/napari-packaging/_work/napari-${{ env.version }}-${{ runner.os }}-${{ env.arch-suffix }}.${{ env.extension }}
          appstore-connect-username: ${{ secrets.APPLE_NOTARIZATION_USERNAME }}
          appstore-connect-password: ${{ secrets.APPLE_NOTARIZATION_PASSWORD }}
          primary-bundle-id: org.napari.pkg
          verbose: true

      - name: Staple Bundle (macOS)
        # We only sign pushes to main, nightlies, RCs and final releases
        if: runner.os == 'macOS' && (github.event_name == 'schedule' || github.event_name == 'push')
        uses: devbotsxyz/xcode-staple@v1
        with:
          product-path: ${{ github.workspace }}/napari-packaging/_work/napari-${{ env.version }}-${{ runner.os }}-${{ env.arch-suffix }}.${{ env.extension }}

      - name: Upload Artifact
        uses: actions/upload-artifact@v2
        # CI artifact uploads only for PRs and pushes to main
        if: github.event_name == 'pull_request' || (github.event_name == 'push' && github.ref_name == 'main')
        with:
          name: napari-${{ env.version }}-${{ runner.os }}-${{ env.arch-suffix }}.${{ env.extension }}
          path: ${{ github.workspace }}/napari-packaging/_work/napari-${{ env.version }}-${{ runner.os }}-${{ env.arch-suffix }}.${{ env.extension }}

      # - name: Get Release
      #   if: startsWith(github.ref, 'refs/tags/v')
      #   id: get_release
      #   uses: bruceadams/get-release@v1.2.3

      # - name: Upload Release Asset
      #   if: startsWith(github.ref, 'refs/tags/v')
      #   uses: actions/upload-release-asset@v1
      #   with:
      #     upload_url: ${{ steps.get_release.outputs.upload_url }}
      #     asset_path: ${{ github.workspace }}/napari-packaging/_work/napari-${{ env.version }}-${{ runner.os }}-${{ env.arch-suffix }}.${{ env.extension }}
      #     asset_name: napari-${{ env.version }}-${{ runner.os }}-${{ env.arch-suffix }}.${{ env.extension }}
      #     asset_content_type: application/octet-stream

      # - name: Upload Nightly Build Asset
      #   if: ${{ github.event_name == 'schedule' }}
      #   uses: WebFreak001/deploy-nightly@v1.1.0
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   with:
      #     # nightly build release from https://api.github.com/repos/napari/napari/releases
      #     upload_url: https://uploads.github.com/repos/napari/napari/releases/34273071/assets{?name,label}
      #     release_id: 34273071
      #     asset_path: ${{ github.workspace }}/napari-packaging/_work/napari-${{ env.version }}-${{ runner.os }}-${{ env.arch-suffix }}.${{ env.extension }}
      #     asset_name: napari-${{ runner.os }}-${{ env.arch-suffix }}.${{ env.extension }}
      #     asset_content_type: application/octet-stream
      #     max_releases: 1

      - name: Test installation (Linux)
        if: runner.os == 'Linux'
        working-directory: napari-packaging/_work
        env:
          CONDA_EXPERIMENTAL_SOLVER: classic
        run: |
          bash napari-${{ env.version }}-${{ runner.os }}-${{ env.arch-suffix }}.${{ env.extension }} -bfp "${{ runner.temp }}/napari-${{ env.version }}"
          . "${{ runner.temp }}/napari-${{ env.version }}/etc/profile.d/conda.sh"
          conda activate "${{ runner.temp }}/napari-${{ env.version }}/envs/napari-${{ env.version }}"
          conda config --show-sources
          conda config --show
          xvfb-run --auto-servernum napari --info

      - name: Test installation (macOS)
        if: runner.os == 'macOS' && matrix.target-platform == 'osx-64'
        working-directory: napari-packaging/_work
        env:
          CONDA_EXPERIMENTAL_SOLVER: classic
        run: |
          set -x
          installer -pkg napari-${{ env.version }}-${{ runner.os }}-${{ env.arch-suffix }}.${{ env.extension }} -target CurrentUserHomeDirectory -dumplog
          . "/Users/runner/Library/napari-${{ env.version }}/etc/profile.d/conda.sh"
          conda activate "/Users/runner/Library/napari-${{ env.version }}/envs/napari-${{ env.version }}"
          conda config --show-sources
          conda config --show
          napari --info

      - name: Test installation (Windows)
        if: runner.os == 'Windows'
        shell: cmd /C call {0}
        working-directory: napari-packaging/_work
        env:
          CONDA_EXPERIMENTAL_SOLVER: classic
        run: |
          cmd.exe /c start /wait napari-${{ env.version }}-${{ runner.os }}-${{ env.arch-suffix }}.${{ env.extension }} /S /D=${{ runner.temp }}\napari-${{ env.version }}
          CALL ${{ runner.temp }}\napari-${{ env.version }}\Scripts\activate ${{ runner.temp }}\napari-${{ env.version }}\envs\napari-${{ env.version }}
          CALL conda config --show-sources
          CALL conda config --show
          napari --info

      # Choose which one to keep; the one in `make_bundle` or this one.
      # - name: Update latest tag
      #   uses: EndBug/latest-tag@latest
      #   if: ${{ github.event_name == 'schedule' }}
      #   with:
      #     description: latest code released from nightly build
      #     tag-name: latest
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
